## Python CLI
As an example let us build a simple command line tool to get the url of an episode video.
I'm gonna use my beloved [f-strings](https://www.python.org/dev/peps/pep-0498/)
which means that you will need Python 3.6 to run it.

**The code is written for Grobber version 3.0.x**

### The Command Line Tool
Let's start with the easy part: the command line interface (CLI).
We're not going to build anything fancy so there's no need to use
a library for this part.

Create a new file called ~~whatever~~ `grobber_cli.py` and open it
with your favourite code editor.

> When I say code editor I'm asking you
> **NOT** to use a text editor like NotePad/Notepad++ but do whatever you want

In order to use your CLI you have to open a terminal in the folder you placed the file
and run `python grobber_cli`. If you go ahead and try this right now you'll be confronted
with the sad reality that code doesn't just write itself. Since we haven't coded anything
nothing happens.
So let's start with the coding:

We want our CLI to accept two arguments, the name of an Anime and the
episode for which we want to output the url.
Luckily, Python exposes the arguments that were passed to the
interpreter under `sys.argv`. In order to use it we need to import the system
library using `import sys`. If you're unfamiliar with Python imports just
place the import statement at the top of your file.

> The following code snippets assume that you've already imported sys

The first element in the argv list is always
going to be the path of the file, we only care about the following arguments
so we can use `sys.argv[1:]` to exclude it.

```python
name, episode = sys.argv[1:]
```

The problem with this is that it's not very user-friendly.
If the user doesn't provide exactly 2 arguments it will crash with an ugly error.
And that's not all, if we wanted to import our code in another file
it would run all of this as well which means that someone else's totally unrelated
code might crash just because the user didn't provide exactly two arguments.
That's pretty stupid, alright? So let's fix it!

In order to solve the first problem let's check whether there were two arguments passed
and fail otherwise.

```python
args = sys.argv[1:]
if len(args) != 2:
    print(f"invalid number of arguments: {len(args)}")
    sys.exit(1)

name, episode = args
```

Now if the user specifies a number of arguments other than two the program exits
with an exit code of 1 and prints a somewhat helpful message.

To address our second problem all we have to do is add a check whether
we're currently being executed or just imported from another location.
We can do this relatively easily because Python sets the global variable `__name__`
to `"__main__"` if the code is being run in the main scope (i.e. executed).
Adding this check results in our code looking like this:

```python
if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) != 2:
        print("invalid number of arguments")
        sys.exit(1)

    name, episode = args
```

Alright. Now we're good to reuse our code in the future without accidentally triggering
some unwanted code.

Now we have both the name and the episode in separate variables. Wonderful.
There's one problem though, all arguments passed to our code are strings.
Obviously our `episode` variable should be a number, not a string. So, before
we move on to the library code, let's just address this problem.

In order to convert a string into an integer in Python we can just use `int(episode)`
because primitive types usually act as converters to said types. But again,
if the user passes something other than an integer Python won't be particularly
amused and raise an ugly `ValueError`. We could use the `str.isnumeric()` method
to check whether we actually got a number in there, but Python is all about the
[EAFP](https://docs.python.org/3/glossary.html#term-eafp)
(Easier to ask for forgiveness than permission) coding style.
So instead of checking whether we have a numeric string at hand, let's just
assume it is one and catch the error (ask for forgiveness) if it isn't.
And since we're building a CLI we can't just exit with an error again, to inform
the user that we're not having his ~~shit~~.

```python
try:
    episode = int(episode)
except ValueError:
    print(f"invalid episode: {episode}")
    sys.exit(1)
```

Alright, now our `episode` is a nice integer.
Now we have all the arguments we need and can pass it to our lib... oh yeah,
we haven't written that part yet. Let's just print out the arguments for now
and get back to this after we've written the library code.

Our code so far:

```python
import sys

if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) != 2:
        print("invalid number of arguments")
        sys.exit(1)

    name, episode = args

    try:
        episode = int(episode)
    except ValueError:
        print(f"invalid episode: {episode}")
        sys.exit(1)

    print(f"getting stream for {name} episode {episode}")
```

### Library Code
Our library consists of only one function `get_stream` which returns
the url to an episode of an  Anime.

Now I know it's bold to put this under the title "Library Code" since it's only
one function but it's our library and we're proud of it dammit!

So let's add an empty (for now) function between the imports and the CLI code:

```python
def get_stream(query: str, episode: int) -> str:
    return ""
```

As you can see our function takes two arguments, `query` to specify the Anime
and `episode` to specify which episode we want to get the stream for.
Because we're no longer living in the dark ages we're giving explicit types
to both our arguments and the return value which makes working with the code
a tad easier (if you're using a decent code editor).

Now what should this function actually do? If you've been a good person you should
already know at least the basics about Grobber's endpoints.
If you don't, here's a quick rundown of the endpoints we're gonna use:

- [`/anime/search`](#anime-search) is used to find an Anime
- [`/anime/episode`](#episode) is used to retrieve data about an episode

How exactly are we gonna use them? Well, here's the plan:

1. Find the uid of an Anime based on `query` using the `search` endpoint
2. Use this uid to get the Episode number `episode`
3. Extract the stream link from the episode or if there is no stream return
an embed url

Sounds reasonably simple, right?

In order to make requests to Grobber we're going to use the Python library
[`requests`](http://python-requests.org/) (Side note: Isn't it ironic that
the website for the most popular http library for Python **doesn't use https**?)
To use it we have to import it, so let's add `import requests` after the `import sys`.

Because we want to keep it somewhat flexible we're going to introduce a global variable
for the Grobber API url. Let's call it `GROBBER_URL` and set it to wherever you're hosting
the Grobber API (don't include the trailing slash).

Now that that's out of the way we're ready to execute our 3-step plan.

> The following code snippets are to be seen as part of the function.

First, let's get the anime. The search endpoints returns a list of search results.
We can just get the response from `requests.get`, parse the JSON response using the
`Response.json()` method and we're pretty much done. Now we have a dictionary
with a single key "anime" containing a list of search results. A search result
consists of the keys "anime", the actual Anime data we care about
and "certainty" which we can ignore for now.
Since we just want to get the first result we don't need to look at all the results.

```python
resp = requests.get(f"{GROBBER_URL}/anime/search/",
                    params=dict(anime=query))

animes = resp.json()["anime"]
anime = animes[0]["anime"]
```

"anime" now contains an Anime object. In order to execute step number 2,
namely getting the episode, we have to get the Anime's uid. Because we can,
let's also get the "episode_count" from the Anime to check whether the episode
we're asking for actually exists. Of course we could go the EAFP route again, but
we have to consider that an API request takes way longer than simply performing
a sanity-check first. To make sure that the episode parameter is reasonable we can use

```python
if episode > episode_count:
    raise IndexError(f"{name!r} only has {episode_count} episode(s)")
```

which raises an `IndexError` if someone is requesting an episode that doesn't exist.
Because Grobber expects the index of an episode, not its number
(i.e. it starts from 0, not 1). That's an easy fix though, we just subtract 1 from
the episode and voilÃ  we got the index.

```python
uid = anime["uid"]
name = anime["title"]
episode_count = anime["episodes"]

if episode > episode_count:
    raise IndexError(f"{name!r} only has {episode_count} episode(s)")

resp = requests.get(f"{GROBBER_URL}/anime/episode/",
                    params=dict(uid=uid, episode=episode-1))

episode = resp.json()["episode"]
```

Alright, all that's left to do is extracting the url and returning it.
Since Grobber cannot always provide a stream we should also provide a fallback
which uses an embed url.

```python
episode = resp.json()["episode"]
stream = episode["stream"]
if stream:
    return stream["links"][0]
else:
    return episode["embeds"][0]
```

And this is what the function looks like:

```python
def get_stream(query: str, episode: int) -> str:
    resp = requests.get(f"{GROBBER_URL}/anime/search/",
                        params=dict(anime=query))

    animes = resp.json()["anime"]
    anime = animes[0]["anime"]

    uid = anime["uid"]
    name = anime["title"]
    episode_count = anime["episodes"]

    if episode > episode_count:
        raise IndexError(f"{name!r} only has {episode_count} episode(s)")

    resp = requests.get(f"{GROBBER_URL}/anime/episode/",
                        params=dict(uid=uid, episode=episode-1))

    episode = resp.json()["episode"]

    stream = episode["stream"]
    if stream:
        return stream["links"][0]
    else:
        return episode["embeds"][0]
```

### Putting it all together
Now that we have the library code and the CLI logic all that's left to do
is putting them together.
Currently we're printing out the name and episode variables in our CLI logic.
Let's just replace that with a call to `get_stream` and print out the resulting string.

```python
args = sys.argv[1:]
if len(args) != 2:
    print("invalid number of arguments")
    sys.exit(1)

name, episode = args

try:
    episode = int(episode)
except ValueError:
    print(f"invalid episode: {episode}")
    sys.exit(1)

print(get_stream(name, episode))
```

And we're done. Now you can play around with your ~~flawless~~ CLI using
`python grobber_cli.py <QUERY> <EPISODE>`.

> If you want to use more than one word for QUERY you have to put them in quotes.
> This results in them being passed as the name argument like you would expect.

As an exercise for the reader you should split up the `get_stream` function into
several functions like `get_anime` and `get_episode` which build upon each other.
Another thing that could really use some love is the CLI. Instead of just
showing an error it might be a good idea to display some help like a signature.
And instead of just showing the raw output one could add some more information
like the name of the Anime.

### Final Code

```python
import sys

import requests

GROBBER_URL = "Your url here"

def get_stream(query: str, episode: int) -> str:
    # search for the anime
    resp = requests.get(f"{GROBBER_URL}/anime/search/",
                        params=dict(anime=query))

    # if the request succeeds the response will be a json object.
    # the search results are stored in the "anime" key.
    animes = resp.json()["anime"]

    # a search result contains "anime" and "certainty".
    # Here we only care about the anime.
    anime = animes[0]["anime"]

    uid = anime["uid"]
    name = anime["title"]
    episode_count = anime["episodes"]

    if episode > episode_count:
        raise IndexError(f"{name!r} only has {episode_count} episode(s)")

    # get the episode. Keep in mind that Grobber accepts episode indices
    # so we subtract one from the input.
    resp = requests.get(f"{GROBBER_URL}/anime/episode/",
                        params=dict(uid=uid, episode=episode-1))

    # if successful the response contains both the "anime" key from before
    # and an "episode" key.
    episode = resp.json()["episode"]

    # Grobber tries to return a url pointing to a video file.
    # Sometimes this is impossible and the stream key will be None
    stream = episode["stream"]
    if stream:
        return stream["links"][0]
    else:
        # if there is no stream for the episode Grobber will still provide a
        # selection of embedded players.
        return episode["embeds"][0]


if __name__ == "__main__":
    # first argument is the file path, ignore it
    args = sys.argv[1:]

    # if there aren't exactly two arguments
    if len(args) != 2:
        print("invalid number of arguments")
        sys.exit(1)

    # extract the two string arguments
    name, episode = args

    # convert episode to an integer or abort
    try:
        episode = int(episode)
    except ValueError:
        print(f"invalid episode: {episode}")
        sys.exit(1)

    # print the result of our little thingy
    print(get_stream(name, episode))
```
