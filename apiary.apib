FORMAT: 1A
HOST: https://mas.dokkeral.com

# Grobber
Grobber is a powerful API providing you with all the Anime and Manga
you could ever need.

**Grobber is not a meta data provider**. If that's what you're looking for,
refer to the [Kitsu API][kitsu-api].
It is an API designed to provide an easy way to fetch Anime episodes
and Manga chapters.

[kitsu-api]: https://kitsu.docs.apiary.io

# Introduction
## UID
UIDs are used to uniquely represent Grobber objects. The new iteration
supports both Anime and Manga objects by using a media type prefix.

In theory you could get the media title from the uid, by reversing the encoding
scheme which is as following:

1. Convert the entire title to lowercase and remove all spaces
2. Find all non-alphanumeric characters (a-z and 0-9) and replace
   them according to the following scheme:
    1. Get the integer Unicode codepoint for this character
    2. Wrap the hexadecimal representation of said integer with underscores

Of course you would have a bit of a problem reversing the first step, but hey,
at least it's something, right?

### Format

EBNF:

```
media type = "a" | "m"
escaped character = "_" hexadecimal character { hexadecimal character } "_"
media id = { lowercase letter | digit | escaped character }
media source = { lowercase letter }
language = "en" | "de"

uid = media type "-" media id "-" media source "-" language [ "_dub" ]
```

or simplified:

`media_type-media_id-source-language(_dub)?`

And here's a regular expression to parse an UID if you ever come across one.
RegExp:

```
^(a|m)-([a-z0-9_]*)-([a-z]*)-([a-z]+?)(_dub)?$
```

### Version 1 (Deprecated)
The previous version of UID had the following format:

```
media id = { lowercase letter | digit | "_" }
media source = { lowercase letter }
language = "en" | "de"

uid = media source "-" media id "-" language [ "_dub" ]
```

There still might be one or two of these old versions floating around.
Grobber will accept them as well.

# Examples
## Dolos
If you're looking for a reference implementation look no further than Dolos,
a browser extension which uses Grobber to embed an episode player on popular
Anime database sites.

You can find the TypeScript code over at [Dolos' GitHub repository][dolos].
Most of the code regarding Grobber can be found in the [`grobber/client.ts` file][dolos-client-file].

[dolos]: https://github.com/MyAnimeStream/dolos
[dolos-clienbt-file]: https://github.com/MyAnimeStream/dolos/blob/master/src/grobber/client.ts

## Python CLI
As an example let us build a simple command line tool to get the url of an episode video.
I'm gonna use my beloved [f-strings](https://www.python.org/dev/peps/pep-0498/)
which means that you will need Python 3.6 to run it.

**The code is written for Grobber version 3.0.x**

### The Command Line Tool
Let's start with the easy part: the command line interface (CLI).
We're not going to build anything fancy so there's no need to use
a library for this part.

Create a new file called ~~whatever~~ `grobber_cli.py` and open it
with your favourite code editor.

> When I say code editor I'm asking you
> **NOT** to use a text editor like NotePad/Notepad++ but do whatever you want

In order to use your CLI you have to open a terminal in the folder you placed the file
and run `python grobber_cli`. If you go ahead and try this right now you'll be confronted
with the sad reality that code doesn't just write itself. Since we haven't coded anything
nothing happens.
So let's start with the coding:

We want our CLI to accept two arguments, the name of an Anime and the
episode for which we want to output the url.
Luckily, Python exposes the arguments that were passed to the
interpreter under `sys.argv`. In order to use it we need to import the system
library using `import sys`. If you're unfamiliar with Python imports just
place the import statement at the top of your file.

> The following code snippets assume that you've already imported sys

The first element in the argv list is always
going to be the path of the file, we only care about the following arguments
so we can use `sys.argv[1:]` to exclude it.

```python
name, episode = sys.argv[1:]
```

The problem with this is that it's not very user-friendly.
If the user doesn't provide exactly 2 arguments it will crash with an ugly error.
And that's not all, if we wanted to import our code in another file
it would run all of this as well which means that someone else's totally unrelated
code might crash just because the user didn't provide exactly two arguments.
That's pretty stupid, alright? So let's fix it!

In order to solve the first problem let's check whether there were two arguments passed
and fail otherwise.

```python
args = sys.argv[1:]
if len(args) != 2:
    print(f"invalid number of arguments: {len(args)}")
    sys.exit(1)

name, episode = args
```

Now if the user specifies a number of arguments other than two the program exits
with an exit code of 1 and prints a somewhat helpful message.

To address our second problem all we have to do is add a check whether
we're currently being executed or just imported from another location.
We can do this relatively easily because Python sets the global variable `__name__`
to `"__main__"` if the code is being run in the main scope (i.e. executed).
Adding this check results in our code looking like this:

```python
if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) != 2:
        print("invalid number of arguments")
        sys.exit(1)

    name, episode = args
```

Alright. Now we're good to reuse our code in the future without accidentally triggering
some unwanted code.

Now we have both the name and the episode in separate variables. Wonderful.
There's one problem though, all arguments passed to our code are strings.
Obviously our `episode` variable should be a number, not a string. So, before
we move on to the library code, let's just address this problem.

In order to convert a string into an integer in Python we can just use `int(episode)`
because primitive types usually act as converters to said types. But again,
if the user passes something other than an integer Python won't be particularly
amused and raise an ugly `ValueError`. We could use the `str.isnumeric()` method
to check whether we actually got a number in there, but Python is all about the
[EAFP](https://docs.python.org/3/glossary.html#term-eafp)
(Easier to ask for forgiveness than permission) coding style.
So instead of checking whether we have a numeric string at hand, let's just
assume it is one and catch the error (ask for forgiveness) if it isn't.
And since we're building a CLI we can't just exit with an error again, to inform
the user that we're not having his ~~shit~~.

```python
try:
    episode = int(episode)
except ValueError:
    print(f"invalid episode: {episode}")
    sys.exit(1)
```

Alright, now our `episode` is a nice integer.
Now we have all the arguments we need and can pass it to our lib... oh yeah,
we haven't written that part yet. Let's just print out the arguments for now
and get back to this after we've written the library code.

Our code so far:

```python
import sys

if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) != 2:
        print("invalid number of arguments")
        sys.exit(1)

    name, episode = args

    try:
        episode = int(episode)
    except ValueError:
        print(f"invalid episode: {episode}")
        sys.exit(1)

    print(f"getting stream for {name} episode {episode}")
```

### Library Code
Our library consists of only one function `get_stream` which returns
the url to an episode of an  Anime.

Now I know it's bold to put this under the title "Library Code" since it's only
one function but it's our library and we're proud of it dammit!

So let's add an empty (for now) function between the imports and the CLI code:

```python
def get_stream(query: str, episode: int) -> str:
    return ""
```

As you can see our function takes two arguments, `query` to specify the Anime
and `episode` to specify which episode we want to get the stream for.
Because we're no longer living in the dark ages we're giving explicit types
to both our arguments and the return value which makes working with the code
a tad easier (if you're using a decent code editor).

Now what should this function actually do? If you've been a good person you should
already know at least the basics about Grobber's endpoints.
If you don't, here's a quick rundown of the endpoints we're gonna use:

- [`/anime/search`](#reference/anime/anime/search-anime) is used to find an Anime
- [`/anime/episode`](#reference/anime/episode/get-episode) is used to retrieve data about an episode

How exactly are we gonna use them? Well, here's the plan:

1. Find the uid of an Anime based on `query` using the `search` endpoint
2. Use this uid to get the Episode number `episode`
3. Extract the stream link from the episode or if there is no stream return
an embed url

Sounds reasonably simple, right?

In order to make requests to Grobber we're going to use the Python library
[`requests`](http://python-requests.org/) (Side note: Isn't it ironic that
the website for the most popular http library for Python **doesn't use https**?)
To use it we have to import it, so let's add `import requests` after the `import sys`.

Because we want to keep it somewhat flexible we're going to introduce a global variable
for the Grobber API url. Let's call it `GROBBER_URL` and set it to wherever you're hosting
the Grobber API (don't include the trailing slash).

Now that that's out of the way we're ready to execute our 3-step plan.

> The following code snippets are to be seen as part of the function.

First, let's get the anime. The search endpoints returns a list of search results.
We can just get the response from `requests.get`, parse the JSON response using the
`Response.json()` method and we're pretty much done. Now we have a dictionary
with a single key "anime" containing a list of search results. A search result
consists of the keys "anime", the actual Anime data we care about
and "certainty" which we can ignore for now.
Since we just want to get the first result we don't need to look at all the results.

```python
resp = requests.get(f"{GROBBER_URL}/anime/search/",
                    params=dict(anime=query))

animes = resp.json()["anime"]
anime = animes[0]["anime"]
```

"anime" now contains an Anime object. In order to execute step number 2,
namely getting the episode, we have to get the Anime's uid. Because we can,
let's also get the "episode_count" from the Anime to check whether the episode
we're asking for actually exists. Of course we could go the EAFP route again, but
we have to consider that an API request takes way longer than simply performing
a sanity-check first. To make sure that the episode parameter is reasonable we can use

```python
if episode > episode_count:
    raise IndexError(f"{name!r} only has {episode_count} episode(s)")
```

which raises an `IndexError` if someone is requesting an episode that doesn't exist.
Because Grobber expects the index of an episode, not its number
(i.e. it starts from 0, not 1). That's an easy fix though, we just subtract 1 from
the episode and voilà we got the index.

```python
uid = anime["uid"]
name = anime["title"]
episode_count = anime["episodes"]

if episode > episode_count:
    raise IndexError(f"{name!r} only has {episode_count} episode(s)")

resp = requests.get(f"{GROBBER_URL}/anime/episode/",
                    params=dict(uid=uid, episode=episode-1))

episode = resp.json()["episode"]
```

Alright, all that's left to do is extracting the url and returning it.
Since Grobber cannot always provide a stream we should also provide a fallback
which uses an embed url.

```python
episode = resp.json()["episode"]
stream = episode["stream"]
if stream:
    return stream["links"][0]
else:
    return episode["embeds"][0]
```

And this is what the function looks like:

```python
def get_stream(query: str, episode: int) -> str:
    resp = requests.get(f"{GROBBER_URL}/anime/search/",
                        params=dict(anime=query))

    animes = resp.json()["anime"]
    anime = animes[0]["anime"]

    uid = anime["uid"]
    name = anime["title"]
    episode_count = anime["episodes"]

    if episode > episode_count:
        raise IndexError(f"{name!r} only has {episode_count} episode(s)")

    resp = requests.get(f"{GROBBER_URL}/anime/episode/",
                        params=dict(uid=uid, episode=episode-1))

    episode = resp.json()["episode"]

    stream = episode["stream"]
    if stream:
        return stream["links"][0]
    else:
        return episode["embeds"][0]
```

### Putting it all together
Now that we have the library code and the CLI logic all that's left to do
is putting them together.
Currently we're printing out the name and episode variables in our CLI logic.
Let's just replace that with a call to `get_stream` and print out the resulting string.

```python
args = sys.argv[1:]
if len(args) != 2:
    print("invalid number of arguments")
    sys.exit(1)

name, episode = args

try:
    episode = int(episode)
except ValueError:
    print(f"invalid episode: {episode}")
    sys.exit(1)

print(get_stream(name, episode))
```

And we're done. Now you can play around with your ~~flawless~~ CLI using
`python grobber_cli.py <QUERY> <EPISODE>`.

> If you want to use more than one word for QUERY you have to put them in quotes.
> This results in them being passed as the name argument like you would expect.

As an exercise for the reader you should split up the `get_stream` function into
several functions like `get_anime` and `get_episode` which build upon each other.
Another thing that could really use some love is the CLI. Instead of just
showing an error it might be a good idea to display some help like a signature.
And instead of just showing the raw output one could add some more information
like the name of the Anime.

### Final Code

```python
import sys

import requests

GROBBER_URL = "Your url here"

def get_stream(query: str, episode: int) -> str:
    # search for the anime
    resp = requests.get(f"{GROBBER_URL}/anime/search/",
                        params=dict(anime=query))

    # if the request succeeds the response will be a json object.
    # the search results are stored in the "anime" key.
    animes = resp.json()["anime"]

    # a search result contains "anime" and "certainty".
    # Here we only care about the anime.
    anime = animes[0]["anime"]

    uid = anime["uid"]
    name = anime["title"]
    episode_count = anime["episodes"]

    if episode > episode_count:
        raise IndexError(f"{name!r} only has {episode_count} episode(s)")

    # get the episode. Keep in mind that Grobber accepts episode indices
    # so we subtract one from the input.
    resp = requests.get(f"{GROBBER_URL}/anime/episode/",
                        params=dict(uid=uid, episode=episode-1))

    # if successful the response contains both the "anime" key from before
    # and an "episode" key.
    episode = resp.json()["episode"]

    # Grobber tries to return a url pointing to a video file.
    # Sometimes this is impossible and the stream key will be None
    stream = episode["stream"]
    if stream:
        return stream["links"][0]
    else:
        # if there is no stream for the episode Grobber will still provide a
        # selection of embedded players.
        return episode["embeds"][0]


if __name__ == "__main__":
    # first argument is the file path, ignore it
    args = sys.argv[1:]

    # if there aren't exactly two arguments
    if len(args) != 2:
        print("invalid number of arguments")
        sys.exit(1)

    # extract the two string arguments
    name, episode = args

    # convert episode to an integer or abort
    try:
        episode = int(episode)
    except ValueError:
        print(f"invalid episode: {episode}")
        sys.exit(1)

    # print the result of our little thingy
    print(get_stream(name, episode))
```

# Group Anime
## Anime [/anime]
These are the endpoints you'll want to use to search for and enquire more information about Anime.

### Search Anime [GET /anime/search/{?anime}{?language}{?dubbed}{?results}]
Before you can actually use any of the other endpoints you need to get an Anime.
The search endpoint does exactly that.
Based on a query (i.e. the name of an Anime) it returns matching results.

Depending on the amount of results (up to `20`) you request,
this operation can take a long time. **You should seldom request search results**
and if you do you should store the details of the result(s)!

The search results are already sorted in descending order by their `certainty` attribute.

+ Parameters
    + anime (string, required, `One Piece`) ... Title of the Anime
    + language (string, optional, `en`) ... Filter for language, defaults to `en`
    + dubbed (boolean, optional, `false`) ... Filter translation type, defaults to `false`
    + results (number, optional, `3`) ... Amount of (SearchResult)s to return, defaults to `1`

+ Response 200 (application/json)
    + Attributes
        + anime (array)
            - (SearchResult)


### Get Anime using UID [GET /anime/{?uid}]
The best way to target an anime is by using its UID. A uid (unique identifier), as its name implies,
uniquely identifies an Anime, including the language and translation type.

+ Parameters
    + uid (string, required, `a-onepiece-masteranime-en`) ... UID to look for

+ Response 200 (application/json)
    + Attributes
        + anime (Anime)


### Get Anime using Title [GET /anime/{?anime}{?language}{?dubbed}]
You can also use the Anime's title to "identify" it.
> Beware that there might be multiple Anime with the same name!
> This method doesn't uniquely identify an Anime.

+ Parameters
    + anime (string, required, `One Piece`) ... Title of the Anime
    + language (string, optional, `en`) ... Filter for language, defaults to `en`
    + dubbed (boolean, optional, `false`) ... Filter translation type, defaults to `false`

+ Response 200 (application/json)
    + Attributes
        + anime (Anime)

## Episode [/anime/episode]
Now let's look at the interesting stuff, episodes.
In order to get an episode you first need to know about the Anime though,
do read up on that if you haven't already.

### Get Episode [GET /anime/episode/{?uid}{?episode}]
> Instead of using the uid of an Anime you may also use the same parameters
> as seen in [**Get Anime using Title**](#reference/anime/anime/get-anime-using-title)

+ Parameters
    + uid (string, required, `a-onepiece-masteranime-en`) ... UID to look for
    + episode (number, required, `5`) ... Episode **index** to fetch. Keep in mind that this is the **index** (i.e. it starts from 0 and goes to \<amount of episodes\> - 1 inclusive!)

+ Response 200 (application/json)
    + Attributes
        + anime (Anime)
        + episode (Episode)

# Group Manga
Coming soon?

# Group Misc
## Grobber Info [/dolos-info]
Get some basic information about this Grobber server.
This endpoint is used by [Dolos](https://github.com/MyAnimeStream/dolos)
to check whether the provided url is valid.

### Get Info [GET]
+ Response 200 (application/json)
    + Attributes
        + id: `grobber`
        + version: `3.0.4`


# Data Structures

## Anime (object)
+ title: `One Piece`
+ uid: `a-onepiece-masteranime-en`
+ language: `en`
+ dubbed: false (boolean)
+ thumbnail:  `https://cdn.masterani.me/poster/646ILh0X4F.jpg`
+ episodes: 868 (number)
+ updated: `2018-12-30T15:41:23.168227` - ISO 8601 timestamp of last update

## Episode (object)
+ embeds: `https://mp4upload.com/embed-7l251136ll9r.html` (array[string])
+ poster: `https://www4.mp4upload.com/i/00457/7l251136ll9r.jpg`
+ stream (Stream, nullable)
+ updated: `2018-12-30T12:00:36.256000`

## Stream (object)
+ type: `Mp4Upload`
+ url: `https://mp4upload.com/embed-wwfu2baijbw5.html`
+ links: `https://www13.mp4upload.com:282/d/q2x3qydhz3b4quuoywuq2jkgkquu22zm3jnl5cygosqxspoouaepgm6r/video.mp4` (array[string])
+ poster: `https://www13.mp4upload.com/i/00457/wwfu2baijbw5.jpg`
+ updated: `2018-12-30T15:41:23.183197`

## SearchResult (object)
+ anime (Anime)
    + uid: `whatever`
+ certainty: 0.6 (number) - Number between 0 and 1 (both ends inclusive) denoting the certainty, that this result matches the provided query.
